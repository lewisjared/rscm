"""
MAGICC regression tests.

Validates RSCM MAGICC implementation against reference outputs
from Fortran MAGICC7. All tests are currently skipped pending
MAGICC component implementation.

Reference data generated by:
  scripts/generate_magicc_regression_data.py

Test scenarios:
  01: Concentration-driven with IPCCTAR forcing method
  02: GHG forcing with OLBL method (modern AR6 approach)
  03: Emissions-driven with full carbon cycle
  04: Climate sensitivity sweep (ECS 1.5-4.5K, parametrised)
  05: CO2-only forcing mode
"""

from __future__ import annotations

import json
from pathlib import Path

import numpy as np
import numpy.testing as npt
import pandas as pd
import pytest

# Reference data location (relative to this file)
REGRESSION_DATA_DIR = Path(__file__).parent / "regression_data" / "magicc"

# Default tolerances for numerical comparisons
DEFAULT_RTOL = 1e-3  # 0.1% relative tolerance
DEFAULT_ATOL = 1e-6  # Absolute tolerance for near-zero values


def load_regression_data(name: str) -> tuple[pd.DataFrame, dict]:
    """
    Load regression test data and config.

    Parameters
    ----------
    name
        Test name (e.g., "01_concentration_driven")

    Returns
    -------
    tuple[pd.DataFrame, dict]
        Long-format DataFrame and config dictionary

    Raises
    ------
    pytest.skip
        If reference data files are not found
    """
    parquet_path = REGRESSION_DATA_DIR / f"{name}.parquet"
    config_path = REGRESSION_DATA_DIR / f"{name}_config.json"

    if not parquet_path.exists():
        pytest.skip(f"Reference data not found: {parquet_path}")

    df = pd.read_parquet(parquet_path)

    # Validate expected columns exist
    expected_cols = {"year", "variable", "unit", "region", "value"}
    actual_cols = set(df.columns)
    if not expected_cols.issubset(actual_cols):
        missing = expected_cols - actual_cols
        msg = f"Parquet file missing columns: {missing}"
        raise ValueError(msg)

    config = {}
    if config_path.exists():
        with open(config_path) as f:
            config = json.load(f)

    return df, config


def get_variable_values(
    df: pd.DataFrame,
    variable: str,
    region: str = "World",
) -> tuple[np.ndarray, np.ndarray]:
    """
    Extract values for a variable as numpy arrays.

    Parameters
    ----------
    df
        Long-format DataFrame from load_regression_data
    variable
        Variable name (MAGICC naming convention)
    region
        Region to filter by (default "World")

    Returns
    -------
    tuple[np.ndarray, np.ndarray]
        (years, values) arrays sorted by year
    """
    subset = df[(df["variable"] == variable) & (df["region"] == region)]
    subset = subset.sort_values("year")

    if len(subset) == 0:
        msg = f"Variable '{variable}' not found for region '{region}'"
        raise ValueError(msg)

    return subset["year"].values, subset["value"].values


def magicc_to_rscm_variable(magicc_var: str) -> str:
    """
    Convert MAGICC variable name to RSCM convention.

    MAGICC uses plural "Concentrations", RSCM uses singular "Concentration".
    """
    return magicc_var.replace("Concentrations", "Concentration")


def rscm_to_magicc_variable(rscm_var: str) -> str:
    """
    Convert RSCM variable name to MAGICC convention (for looking up reference data).
    """
    return rscm_var.replace("Concentration|", "Concentrations|")


@pytest.mark.skip(reason="MAGICC GHGForcingComponent not implemented")
def test_01_concentration_driven():
    """
    Test 1: Concentration-driven run with IPCCTAR forcing method.

    Validates GHG forcing calculation and climate response using SSP245
    concentration pathways. Uses IPCCTAR radiative forcing method for
    simpler validation.

    Variables compared:
    - Atmospheric Concentrations|CO2/CH4/N2O (input pass-through)
    - Effective Radiative Forcing|CO2/CH4/N2O
    - Surface Temperature
    """
    df, config = load_regression_data("01_concentration_driven")

    # Verify config matches expected
    assert config.get("core_co2ch4n2o_rfmethod") == "IPCCTAR"
    assert config.get("core_climatesensitivity") == 3.0

    # Extract expected values
    years, expected_co2_conc = get_variable_values(df, "Atmospheric Concentrations|CO2")
    _, expected_erf_co2 = get_variable_values(df, "Effective Radiative Forcing|CO2")
    _, expected_temp = get_variable_values(df, "Surface Temperature")

    # Verify data was loaded
    assert len(years) > 0
    assert len(expected_co2_conc) == len(years)
    assert len(expected_erf_co2) == len(years)
    assert len(expected_temp) == len(years)

    # TODO: When GHGForcingComponent and ClimateComponent are implemented:
    # 1. Build model with IPCCTAR forcing method
    # 2. Load SSP245 concentration inputs
    # 3. Run model
    # 4. Compare outputs:
    #    npt.assert_allclose(actual_erf_co2, expected_erf_co2, rtol=1e-3)
    #    npt.assert_allclose(actual_temp, expected_temp, rtol=1e-3)


@pytest.mark.skip(reason="MAGICC GHGForcingComponent (OLBL method) not implemented")
def test_02_ghg_forcing_olbl():
    """
    Test 2: GHG forcing with OLBL method.

    Validates GHG forcing calculation using the modern OLBL (Optimal Linear
    Basis Level) method with rapid adjustment factors, as used in AR6.

    Config:
    - core_co2ch4n2o_rfmethod: OLBL
    - Rapid adjustment factors: CO2=1.05, CH4=0.86, N2O=0.93

    Variables compared:
    - Effective Radiative Forcing|CO2/CH4/N2O
    - Surface Temperature
    """
    df, config = load_regression_data("02_ghg_forcing_olbl")

    # Verify config matches expected
    assert config.get("core_co2ch4n2o_rfmethod") == "OLBL"
    assert config.get("core_rfrapidadjust_co2") == 1.05
    assert config.get("core_rfrapidadjust_ch4") == 0.86
    assert config.get("core_rfrapidadjust_n2o") == 0.93

    # Extract expected values
    years, expected_erf_co2 = get_variable_values(df, "Effective Radiative Forcing|CO2")
    _, _expected_erf_ch4 = get_variable_values(df, "Effective Radiative Forcing|CH4")
    _, _expected_erf_n2o = get_variable_values(df, "Effective Radiative Forcing|N2O")
    _, _expected_temp = get_variable_values(df, "Surface Temperature")

    # Verify data was loaded
    assert len(years) > 0
    assert len(expected_erf_co2) == len(years)

    # TODO: When GHGForcingComponent with OLBL is implemented:
    # 1. Build model with OLBL forcing method and rapid adjustment factors
    # 2. Load SSP245 concentration inputs
    # 3. Run model
    # 4. Compare ERF outputs against reference


@pytest.mark.skip(reason="MAGICC carbon cycle and chemistry components not implemented")
def test_03_emissions_driven():
    """
    Test 3: Emissions-driven run with full carbon cycle.

    Validates the complete emissions-to-concentration-to-forcing-to-temperature
    pathway using SSP245 emissions scenario.

    Variables compared:
    - Atmospheric Concentrations|CO2/CH4/N2O (calculated from emissions)
    - Surface Temperature
    """
    df, _config = load_regression_data("03_emissions_driven")

    # Extract expected values
    years, expected_co2_conc = get_variable_values(df, "Atmospheric Concentrations|CO2")
    _, _expected_ch4_conc = get_variable_values(df, "Atmospheric Concentrations|CH4")
    _, _expected_n2o_conc = get_variable_values(df, "Atmospheric Concentrations|N2O")
    _, _expected_temp = get_variable_values(df, "Surface Temperature")

    # Verify data was loaded
    assert len(years) > 0
    assert len(expected_co2_conc) == len(years)

    # TODO: When carbon cycle and chemistry components are implemented:
    # 1. Build model with full carbon cycle
    # 2. Load SSP245 emissions inputs
    # 3. Run model
    # 4. Compare concentration and temperature outputs


@pytest.mark.skip(reason="MAGICC ClimateComponent not implemented")
@pytest.mark.parametrize("ecs", [1.5, 2.0, 3.0, 4.0, 4.5])
def test_04_ecs_sweep(ecs: float):
    """
    Test 4: Climate sensitivity parameter sweep.

    Validates climate response for different Equilibrium Climate Sensitivity
    (ECS) values ranging from 1.5K to 4.5K using SSP245 CO2 concentration
    pathway.

    Parameters
    ----------
    ecs
        Equilibrium Climate Sensitivity value in Kelvin

    Variables compared:
    - Surface Temperature (primary validation target)
    - Effective Radiative Forcing|CO2 (should be identical across ECS values)
    """
    df, config = load_regression_data(f"04_ecs_sweep_{ecs}")

    # Verify config matches expected ECS
    assert config.get("core_climatesensitivity") == ecs

    # Extract expected values
    years, expected_temp = get_variable_values(df, "Surface Temperature")
    _, _expected_erf_co2 = get_variable_values(df, "Effective Radiative Forcing|CO2")

    # Verify data was loaded
    assert len(years) > 0
    assert len(expected_temp) == len(years)

    # TODO: When ClimateComponent is implemented:
    # 1. Build model with specified ECS parameter
    # 2. Load SSP245 CO2 concentration inputs
    # 3. Run model
    # 4. Compare surface temperature
    #    npt.assert_allclose(actual_temp, expected_temp, rtol=1e-3)


@pytest.mark.skip(reason="MAGICC forcing run mode selection not implemented")
def test_05_co2_only_forcing():
    """
    Test 5: CO2-only forcing mode.

    Validates that total forcing equals CO2 forcing when running in CO2-only
    mode. This isolates the CO2 forcing pathway for clean validation.

    Config:
    - rf_total_runmodus: CO2 (only CO2 forcing contributes)

    Variables compared:
    - Effective Radiative Forcing (total should equal CO2 forcing)
    - Effective Radiative Forcing|CO2
    - Surface Temperature
    """
    df, config = load_regression_data("05_co2_only_forcing")

    # Verify config
    assert config.get("rf_total_runmodus") == "CO2"

    # Extract expected values
    years, expected_total_erf = get_variable_values(df, "Effective Radiative Forcing")
    _, expected_erf_co2 = get_variable_values(df, "Effective Radiative Forcing|CO2")
    _, _expected_temp = get_variable_values(df, "Surface Temperature")

    # Verify data was loaded
    assert len(years) > 0

    # In CO2-only mode, total ERF should equal CO2 ERF
    # (This is a sanity check on the reference data)
    npt.assert_allclose(expected_total_erf, expected_erf_co2, rtol=1e-6)

    # TODO: When forcing run mode selection is implemented:
    # 1. Build model with CO2-only forcing mode
    # 2. Run model
    # 3. Verify total ERF equals CO2 ERF
    # 4. Compare temperature response
