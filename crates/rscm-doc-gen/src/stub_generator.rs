//! Generate Python type stub files (.pyi) from component metadata

use crate::schema::{ComponentDocMetadata, ParameterMetadata};
use std::fs;
use std::path::Path;

/// Generate Python type stub files for components
pub fn generate_stubs(
    components: &[ComponentDocMetadata],
    output_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    // Group components by module
    let mut components_by_module: std::collections::BTreeMap<String, Vec<&ComponentDocMetadata>> =
        std::collections::BTreeMap::new();

    for component in components {
        // Infer module name from module_path
        // e.g., "rscm_components::components::carbon_cycle" -> "components"
        let module_name = extract_module_name(&component.module_path);
        components_by_module
            .entry(module_name)
            .or_insert_with(Vec::new)
            .push(component);
    }

    // Generate stub files for each module
    for (module_name, module_components) in components_by_module {
        // Replace :: with _ in filename
        let filename = module_name.replace("::", "_");
        let output_file = output_dir.join(format!("{}.pyi", filename));
        let stub_content = generate_module_stub(&module_name, &module_components)?;
        fs::write(&output_file, stub_content)?;
        println!("Generated {}", output_file.display());
    }

    Ok(())
}

/// Extract module name from fully qualified module path for stub file organization
/// e.g., "rscm_components::components::carbon_cycle" -> "components"
/// e.g., "rscm_components::components::ocean_carbon_cycle::ospp" -> "components_ocean_carbon_cycle"
/// e.g., "rscm_two_layer::component" -> "two_layer"
fn extract_module_name(module_path: &str) -> String {
    let parts: Vec<&str> = module_path.split("::").collect();

    if parts.is_empty() {
        return module_path.to_string();
    }

    // For rscm_components crates:
    // - If it's rscm_components::components::ComponentName, use "components"
    // - If it's rscm_components::components::submodule::ComponentName, use "components_submodule"
    if parts[0].starts_with("rscm_components") && parts.len() >= 3 {
        // parts[0] = crate, parts[1] = "components", parts[2..n-1] = submodules, parts[n-1] = component
        if parts.len() == 3 {
            // Direct component in components module
            return "components".to_string();
        } else if parts.len() > 3 {
            // Component in a submodule - use "components_submodule1_submodule2"
            let mut result = "components".to_string();
            for i in 2..parts.len() - 1 {
                result.push('_');
                result.push_str(parts[i]);
            }
            return result;
        }
    }

    // For rscm_two_layer, use the crate name
    if parts[0].starts_with("rscm_two_layer") {
        return "two_layer".to_string();
    }

    // Default: use the module path minus the last component
    if parts.len() >= 2 {
        parts[..parts.len() - 1].join("_")
    } else {
        module_path.to_string()
    }
}

/// Generate Python stub content for a module
fn generate_module_stub(
    _module_name: &str,
    components: &[&ComponentDocMetadata],
) -> Result<String, Box<dyn std::error::Error>> {
    let mut lines = Vec::new();

    // Add header
    lines.push("# Auto-generated Python type stubs for RSCM components".to_string());
    lines.push("# This file is generated by rscm-doc-gen - do not edit manually".to_string());
    lines.push("".to_string());
    lines.push("from typing import TypedDict".to_string());
    lines.push("from rscm._lib.core import ComponentBuilder, RustComponent".to_string());
    lines.push("".to_string());

    // Generate TypedDict and Builder classes for each component
    for component in components {
        // Generate TypedDict for parameters
        if !component.parameters.is_empty() {
            lines.push(generate_parameter_typeddict(component)?);
            lines.push("".to_string());
        }

        // Generate Builder class
        lines.push(generate_builder_class(component)?);
        lines.push("".to_string());
    }

    Ok(lines.join("\n"))
}

/// Generate a TypedDict class for component parameters
fn generate_parameter_typeddict(
    component: &ComponentDocMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut lines = Vec::new();

    let typeddict_name = format!("{}Params", component.name);
    let doc_summary = if let Some(desc) = component.description.lines().next() {
        desc.to_string()
    } else {
        format!("Parameters for {} component", component.name)
    };

    lines.push(format!("class {}(TypedDict):", typeddict_name));
    lines.push(format!("    \"\"\"{}\"\"\"", doc_summary));

    // Generate field definitions
    for param in &component.parameters {
        let param_doc = format_parameter_doc(param);
        if !param_doc.is_empty() {
            // Wrap long documentation comments
            for doc_line in param_doc.lines() {
                if doc_line.len() > 80 {
                    lines.push(format!(
                        "    # {}",
                        &doc_line[..std::cmp::min(80, doc_line.len())]
                    ));
                } else {
                    lines.push(format!("    # {}", doc_line));
                }
            }
        }
        lines.push(format!("    {}: {}", param.name, param.python_type));
    }

    Ok(lines.join("\n"))
}

/// Generate a Builder class with typed from_parameters method
fn generate_builder_class(
    component: &ComponentDocMetadata,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut lines = Vec::new();

    let builder_name = format!("{}Builder", component.name);
    let typeddict_name = format!("{}Params", component.name);

    lines.push(format!("class {}(ComponentBuilder):", builder_name));

    // Add builder docstring
    if !component.description.is_empty() {
        // Use first line of description
        let desc_short = component
            .description
            .lines()
            .next()
            .unwrap_or("")
            .to_string();
        if !desc_short.is_empty() {
            lines.push(format!("    \"\"\"{}\"\"\"", desc_short));
        } else {
            lines.push(format!(
                "    \"\"\"Component builder for {}\"\"\"",
                component.name
            ));
        }
    } else {
        lines.push(format!(
            "    \"\"\"Component builder for {}\"\"\"",
            component.name
        ));
    }

    // Generate from_parameters method with proper signature
    if !component.parameters.is_empty() {
        lines.push(format!("    @classmethod"));
        lines.push(format!(
            "    def from_parameters(cls, parameters: {}) -> {}:",
            typeddict_name, builder_name
        ));
        lines.push(format!(
            "        \"\"\"Create a builder from a parameter dictionary.\"\"\""
        ));
        lines.push(format!("        ..."));
    }

    // Generate build method
    lines.push(format!("    def build(self) -> RustComponent:"));
    lines.push(format!("        \"\"\"Build the component.\"\"\""));
    lines.push(format!("        ..."));

    Ok(lines.join("\n"))
}

/// Format parameter documentation
fn format_parameter_doc(param: &ParameterMetadata) -> String {
    let mut parts = Vec::new();

    if !param.description.is_empty() {
        // Get first line of description (before unit info)
        let desc_lines: Vec<&str> = param.description.lines().collect();
        if !desc_lines.is_empty() && !desc_lines[0].contains("unit:") {
            parts.push(desc_lines[0].to_string());
        }
    }

    if !param.unit.is_empty() {
        parts.push(format!("unit: {}", param.unit));
    }

    parts.join(" - ")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_module_name() {
        assert_eq!(
            extract_module_name("rscm_components::components::carbon_cycle"),
            "components"
        );
        assert_eq!(
            extract_module_name("rscm_components::components::ocean_carbon_cycle::ospp"),
            "components_ocean_carbon_cycle"
        );
        assert_eq!(
            extract_module_name("rscm_two_layer::component"),
            "two_layer"
        );
    }

    #[test]
    fn test_format_parameter_doc() {
        let param = ParameterMetadata {
            name: "tau".to_string(),
            rust_type: "FloatValue".to_string(),
            python_type: "float".to_string(),
            unit: "yr".to_string(),
            description: "Timescale of the box's response\nunit: yr".to_string(),
            default: None,
            nested_fields: None,
        };

        let doc = format_parameter_doc(&param);
        assert!(doc.contains("Timescale"));
        assert!(doc.contains("yr"));
    }
}
